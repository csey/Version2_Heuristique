/* Utilisation de GLPK en mode bibliothèque */
/* Il s'agit d'un problème de node packing : 2 variables x et y interviennent dans chaque contrainte du type "x + y <= 1" */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glpk.h> /* nous allons utiliser la bibliothèque de fonctions de GLPK */

#define NBCONFLITS 15 
/* NBCONFLITS : constante spécifique à l'instance considérée
   Dans un contexte plus large (instances de node packing en général), on lirait l'instance (nombre de conflits + paires de variables associées) dans un fichier
   On se permet ici des allocations statiques, mais des allocations dynamiques ne sont pas inappropriées en général */
#define NBVAR 12
/* NBVAR : nombre de variables */

int main(void)
{
	/* structures de données propres à GLPK*/
	glp_prob *prob; // déclaration d'un pointeur sur le problème
	int ia[1 + 2 * NBCONFLITS], ja[1 + 2 * NBCONFLITS];
	double ar[1 + 2 * NBCONFLITS]; // déclaration des 3 tableaux servant à définir la matrice "creuse" des contraintes
	                               // Le "1 + " est dû au fait que les indices commencent à 1 dans GLPK, la case 0 sera donc inutilisée  

	
	/* autres déclarations */
	int i;
	char nomcontr[NBCONFLITS][10];
	char numero[NBCONFLITS][3];	
	char nomvar[NBVAR][2]; /* 3 tableaux de chaines de caractères ayant pour but de définir les noms des contraintes et des variables */
    double z, x[NBVAR]; /* variables récupérant les résultats de l'optimisation (fonction objectif et variables) */

	prob = glp_create_prob(); /* allocation mémoire pour le problème */ 
	glp_set_prob_name(prob, "pizza"); /* affectation d'un nom (on pourrait mettre NULL) */
	glp_set_obj_dir(prob, GLP_MAX); /* Il s'agit d'un problème de maximisation */
	
	glp_add_rows(prob, NBCONFLITS); /* Déclaration du nombre de lignes de la matrice de contraintes : NBCONFLITS */
	for(i=1;i<=NBCONFLITS;i++)
	{
		strcpy(nomcontr[i-1], "conflit");
		sprintf(numero[i-1], "%d", i);
		strcat(nomcontr[i-1], numero[i-1]); /* Les conflits sont nommés "conflit1", "conflit2"... */		
		glp_set_row_name(prob, i, nomcontr[i-1]); /* la contrainte 1 (on commence à 1) est nommée "conflit1"...*/
		glp_set_row_bnds(prob, i, GLP_UP, 0.0, 1.0); 
		/* Avec GLPK, on peut définir simultanément deux contraintes, si par exemple, on a pour une contrainte i : "x + y >= 0" et "x + y <= 5",
		   on écrit alors : glp_set_row_bnds(prob, i, GLP_DB, 0.0, 5.0); la constante GLP_DB signifie qu'il y a deux bornes sur "x + y" qui sont ensuite données 
		   Ici, nous n'avons qu'une seule contrainte du type "x + y <= 1" soit une borne supérieure sur "x + y", on écrit donc glp_set_row_bnds(prob, i, GLP_UP, 0.0, 1.0); le paramètre "0.0" est ignoré 
		   Remarque : les membres de gauches des contraintes (x + y) ne sont pas encore saisies, les variables n'étant pas encore déclarées */ 
	}	

	glp_add_cols(prob, NBVAR); /* Déclaration du nombre de variables : NBVAR */
	for(i=1;i<=NBVAR;i++)
	{
		sprintf(nomvar[i-1],"%c",'A'+i-1);
		glp_set_col_name(prob, i , nomvar[i-1]); /* Les variables sont nommées "A", "B"...*/
		glp_set_col_bnds(prob, i, GLP_DB, 0.0, 1.0); /* bornes sur les variables, comme sur les contraintes */
		glp_set_col_kind(prob, i, GLP_BV);	/* les variables sont par défaut continues, nous précisons ici qu'elles sont binaires avec la constante GLP_BV, on utiliserait GLP_IV pour des variables entières */	
	} 

	/* définitions des coefficients des variables dans la fonction objectif */
	glp_set_obj_coef(prob, 1, 10.0);
	glp_set_obj_coef(prob, 2, 12.0);
	glp_set_obj_coef(prob, 3, 10.0);
	glp_set_obj_coef(prob, 4, 11.0);
	glp_set_obj_coef(prob, 5, 14.0);
	glp_set_obj_coef(prob, 6, 12.0);
	glp_set_obj_coef(prob, 7, 13.0);
	glp_set_obj_coef(prob, 8, 12.0);
	glp_set_obj_coef(prob, 9, 10.0);
	glp_set_obj_coef(prob, 10, 11.0);
	glp_set_obj_coef(prob, 11, 9.0);
	glp_set_obj_coef(prob, 12, 12.0);
	
	/* Définition des coefficients non-nuls dans la matrice des contraintes */
	ia[1] = 1, ja[1] = 1, ar[1] = 1.0;  /* à la position (i,j) = (1,1) on a un 1.0 */
	ia[2] = 1, ja[2] = 2, ar[2] = 1.0;  /* ... */
	ia[3] = 2, ja[3] = 1, ar[3] = 1.0;
	ia[4] = 2, ja[4] = 10, ar[4] = 1.0;
	ia[5] = 3, ja[5] = 2, ar[5] = 1.0;
	ia[6] = 3, ja[6] = 11, ar[6] = 1.0;
	ia[7] = 4, ja[7] = 2, ar[7] = 1.0;
	ia[8] = 4, ja[8] = 12, ar[8] = 1.0;
	ia[9] = 5, ja[9] = 3, ar[9] = 1.0;
	ia[10] = 5, ja[10] = 7, ar[10] = 1.0;
	ia[11] = 6, ja[11] = 3, ar[11] = 1.0;
	ia[12] = 6, ja[12] = 8, ar[12] = 1.0;
	ia[13] = 7, ja[13] = 3, ar[13] = 1.0;
	ia[14] = 7, ja[14] = 12, ar[14] = 1.0;
	ia[15] = 8, ja[15] = 4, ar[15] = 1.0;
	ia[16] = 8, ja[16] = 5, ar[16] = 1.0;
	ia[17] = 9, ja[17] = 5, ar[17] = 1.0;
	ia[18] = 9, ja[18] = 6, ar[18] = 1.0;
	ia[19] = 10, ja[19] = 7, ar[19] = 1.0;
	ia[20] = 10, ja[20] = 8, ar[20] = 1.0;
	ia[21] = 11, ja[21] = 7, ar[21] = 1.0;
	ia[22] = 11, ja[22] = 10, ar[22] = 1.0;
	ia[23] = 12, ja[23] = 8, ar[23] = 1.0;
	ia[24] = 12, ja[24] = 10, ar[24] = 1.0;
	ia[25] = 13, ja[25] = 9, ar[25] = 1.0;
	ia[26] = 13, ja[26] = 11, ar[26] = 1.0;
	ia[27] = 14, ja[27] = 9, ar[27] = 1.0;
	ia[28] = 14, ja[28] = 12, ar[28] = 1.0;
	ia[29] = 15, ja[29] = 10, ar[29] = 1.0;
	ia[30] = 15, ja[30] = 12, ar[30] = 1.0;

	/* 
	Comme nous sommes conscients qu'il s'agit d'un problème de node-packing, nous savons que deux variables interviennent dans chaque contrainte avec un coefficient de 1.0,
	nous aurions donc pu écrire plus simplement :
	
	for(i=0;i<NBCONFLITS;i++)
	{
		ia[2*i+1] = i+1;
		ia[2*i+2] = i+1;
	}	
	for(i=1;i<=2*NBCONFLITS;i++) 
	{
		ar[i] = 1.0;
		ja[1] = 1,ja[2] = 2; // définition de chaque contrainte en une ligne (ici, "A + B") 	
		ja[3] = 1,ja[4] = 10;
	...
	}
	*/
	
	glp_load_matrix(prob,30,ia,ja,ar); /* chargement de la matrice dans le problème */
	
	glp_simplex(prob,NULL);	
	glp_intopt(prob,NULL); /* Résolution */
	z = glp_mip_obj_val(prob); /* Récupération de la valeur optimale */
	// Dans le cas d'un problème en variables continues, l'appel est différent : z = glp_get_obj_val(prob);	
	for(i=0;i<NBVAR;i++) x[i] = glp_mip_col_val(prob,i+1); /* Récupération de la valeur des variables */
	// Appel différent dans le cas d'un problème en variables continues : for(i=0;i<NBVAR;i++) x[i] = glp_get_col_prim(prob,i+1);	
	printf("z = %lf\n",z);
	for(i=0;i<NBVAR;i++) printf("%c = %d, ",'A'+i,(int)(x[i] + 0.5)); /* un cast est ajouté, x[i] pourrait être égal à 0.99999... */ 
	puts("");

	glp_delete_prob(prob); /* libération mémoire du problème */
	return 0;
}
